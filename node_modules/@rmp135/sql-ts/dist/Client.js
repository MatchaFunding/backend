import * as ConfigTasks from './ConfigTasks.js';
import * as DatabaseTasks from './DatabaseTasks.js';
import * as ConnectionFactory from './ConnectionFactory.js';
export class Client {
    config;
    databaseProvider;
    databaseMappings = [];
    constructor() { }
    /**
     * Creates a new Client with the given sql-ts configuration
     * @param config The configuration object for the database
     * @returns A Client with the given configuration
     */
    static fromConfig(config) {
        const client = new Client();
        client.config = ConfigTasks.applyConfigDefaults(config);
        return client;
    }
    /**
     * Creates a new Client with the given database definition from {@link ClientWithDatabase.toObject}
     * @param schema The database definition to use
     * @param config The sql-ts configuration object
     * @returns A Client with the given database schema
     */
    static fromObject(schema, config) {
        const client = new Client();
        client.config = ConfigTasks.applyConfigDefaults(config);
        client.databaseProvider = () => Promise.resolve(schema);
        return client;
    }
    fetchDatabase(db) {
        this.databaseProvider = async () => {
            if (db == null) {
                return await ConnectionFactory.createAndRun(this.config, tempdb => DatabaseTasks.generateDatabase(this.config, tempdb));
            }
            return await DatabaseTasks.generateDatabase(this.config, db);
        };
        return this;
    }
    mapTable(identifer, func) {
        this.databaseMappings.push((database) => {
            for (const schema of database.schemas) {
                schema.tables = schema.tables.map(table => `${schema.name}.${table.name}` === identifer ? func(table, schema) : table);
            }
        });
        return this;
    }
    mapTables(func) {
        this.databaseMappings.push((database) => {
            for (const schema of database.schemas) {
                schema.tables = schema.tables.map(table => func(table, schema));
            }
        });
        return this;
    }
    mapColumn(identifier, func) {
        this.databaseMappings.push((database) => {
            for (const schema of database.schemas) {
                for (const table of schema.tables) {
                    table.columns = table.columns.map(column => `${schema.name}.${table.name}.${column.name}` === identifier ? func(column, table, schema) : column);
                }
            }
        });
        return this;
    }
    mapColumns(func) {
        this.databaseMappings.push((database) => {
            for (const schema of database.schemas) {
                for (const table of schema.tables) {
                    table.columns = table.columns.map(column => func(column, table, schema));
                }
            }
        });
        return this;
    }
    mapSchema(identifier, func) {
        this.databaseMappings.push((database) => {
            database.schemas = database.schemas.map(schema => schema.name === identifier ? func(schema) : schema);
        });
        return this;
    }
    mapSchemas(func) {
        this.databaseMappings.push((database) => {
            database.schemas = database.schemas.map(schema => func(schema));
        });
        return this;
    }
    async toTypescript() {
        const schema = await this.toObject();
        return DatabaseTasks.convertDatabaseToTypescript(schema, this.config);
    }
    async toObject() {
        const database = await this.databaseProvider();
        for (const mapping of this.databaseMappings) {
            mapping(database);
        }
        return database;
    }
}
//# sourceMappingURL=Client.js.map